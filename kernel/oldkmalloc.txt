// I've been wanting to use a new way and I found a bug anyway that I didn't want
// to figure out, one freenode's next pointer was itself for some reason!

// kernel.h
static struct FreeNode
{
    void* ptr;
    unsigned int size;
    struct FreeNode* prev;
    struct FreeNode* next;
} *first_free, *last_free;
struct MemHeader
{
    unsigned int size;
};

// kernel.c
static inline struct FreeNode* kbestfreeblock(int size)
{
    struct FreeNode* free = first_free;
    struct FreeNode* best = 0;
    while (free)
    {
        if ((free->size >= size) && ((best == 0) || (best->size > free->size))) best = free;
        free = free->next;
    }
    return best;
}

static inline struct FreeNode* kfirstfreeblock(int size)
{
    struct FreeNode* free = first_free;
    while (free)
    {
        if (free->size >= size) return free;
        free = free->next;
    }
    return 0;
}

static inline void unlink_freenode(struct FreeNode* free)
{
    // unlink the free node.
    if (free->prev)
        free->prev->next = free->next;
    else
        first_free = free->next;
    if (free->next)
        free->next->prev = free->prev;
    else
        last_free = free->prev;
}

static inline void free_freenode(struct FreeNode* free)
{
    unlink_freenode(free);
    kfree(free);
}

// Returns pointer to header structure of an allocated memory address
static inline struct MemHeader* mhead(void* ptr) { return (struct MemHeader*)((unsigned)ptr-sizeof(struct MemHeader)); }

void* kmalloc(int size)
{
    struct FreeNode* free = kbestfreeblock(size); // faster: kfirstfreeblock()
    void* ptr;
    int s;
    if (free)
    {
        ptr = free->ptr;
        // use the whole block if the remaining space
        // is too small for a header and at least an extra byte.
        if (free->size <= size+sizeof(struct MemHeader))
        {
            mhead(ptr)->size = free->size;
            free_freenode(free);
        }
        else
        {
            // Use part of the free block; update the information
            free->size -= size+sizeof(struct MemHeader);
            free->ptr += size+sizeof(struct MemHeader);
            mhead(ptr)->size = size;
        }
        return ptr;
    }
    else
    {
        // Use the end of the heap
        s = sizeof(struct MemHeader)+size;
        void* t = heap_end;
        while (t+s > heap_brk) if (!ksbrk(1)) return 0;
        heap_end = t+s;
        ((struct MemHeader*)t)->size = size;
        return t+sizeof(struct MemHeader);
    }
}

void kfree(void* ptr)
{
    // find the largest area that we can free.
    // If at the end of heap, just set heap_end.
    // Otherwise, mark that area as free.
    if (!ptr) return;

    struct FreeNode *free, *free2, *freeprev = 0, *freenext = 0, tfree;
    // Find the actual free space determined by any adjacent free blocks
    void* newptr = ptr;
    unsigned newsize = mhead(ptr)->size;
    free2 = first_free;
    while (free2)
    {
        if ((free2->ptr + free2->size + sizeof(struct MemHeader)) == ptr)
        {
            freeprev = free2;
            newptr = free2->ptr;
            newsize += free2->size + sizeof(struct MemHeader);
        }
        else if ((ptr + mhead(ptr)->size + sizeof(struct MemHeader)) == free2->ptr)
        {
            freenext = free2;
            newsize += free2->size + sizeof(struct MemHeader);
        }
        free2 = free2->next;
    }
    // Unlink any freenodes to adjacent free blocks
    if (freeprev) unlink_freenode(freeprev);
    if (freenext) unlink_freenode(freenext);
    // Is this block at the end of the heap?
    if ((newptr + newsize) == heap_end)
    {
        // All we have to do is move the end of the heap!
        heap_end = mhead(newptr);
        // cleanup duty
        if (freeprev) kfree(freeprev);
        if (freenext) kfree(freenext);
        return;
    }
    // our new freenode
    tfree.ptr = newptr;
    tfree.size = newsize;
    tfree.prev = 0;
    tfree.next = first_free;
    // try and reuse one
    if (freeprev)
    {
        free = freeprev;
        if (freenext) kfree(freenext); // don't need it any more
    }
    else if (freenext)
    {
        free = freenext;
        // 'freeprev' takes precedence over 'freenext'
    }
    else
    {
        free = kmalloc(sizeof(struct FreeNode)); // Easy; If we're out of memory, nothing to do
        if (!free) return; // We've reached a dead end! // XXX Try to (carefully) use the block we're freeing
    }
    // Link it in
    
    *free = tfree;
    if (first_free) first_free->prev = free;
    first_free = free;
    /* end of kfree() */

    /* The simple method below does not combine any free blocks */
    /*
    struct FreeNode* free;
    free = kmalloc(sizeof(struct FreeNode)); // assumes there is enough memory
    free->ptr = ptr;
    free->size = mhead(ptr)->size;
    // link it in
    free->prev = 0;
    free->next = first_free;
    if (first_free) first_free->prev = free;
    first_free = free;
    */
}